/**
 * @module ImageTracerLayers
 * @description SVGのレイヤー管理機能を提供するモジュール
 * @version 4.0.0
 * @license MIT
 * 
 * このモジュールはSVGのレイヤー分離、イラストレーター互換レイヤー構造、
 * レイヤー表示・色変更などの機能を提供します。
 * Photopea、Illustrator、その他のグラフィックソフトウェア互換のレイヤー構造をサポートします。
 */

// グローバル名前空間にImageTracerLayersを定義
window.ImageTracerLayers = (function() {
  'use strict';
  
  // プライベート変数
  const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
  const ILLUSTRATOR_NAMESPACE = 'http://ns.adobe.com/AdobeIllustrator/10.0/';
  const GRAPHICS_NAMESPACE = 'http://ns.adobe.com/Graphs/1.0/';
  const PHOTOPEA_NAMESPACE = 'http://www.photopea.com';
  
  /**
   * SVGレイヤーを作成します
   * @param {Array} colors - 色情報の配列
   * @param {Object} options - オプション設定
   * @returns {Array} レイヤー情報の配列
   */
  function createLayers(colors, options = {}) {
    const layers = [];
    
    // 各色に対してレイヤーを作成
    colors.forEach((color, index) => {
      const layerName = getLayerName(color, index, options.layerNaming);
      const colorHex = rgbToHex(color[0], color[1], color[2]);
      
      layers.push({
        id: 'layer' + index,
        name: layerName,
        color: colorHex,
        index: index,
        visible: true
      });
    });
    
    return layers;
  }
  
  /**
   * レイヤー名を生成します
   * @param {Array} color - 色情報 [R, G, B]
   * @param {number} index - レイヤーインデックス
   * @param {string} namingMode - 命名モード ('color', 'index', 'auto')
   * @returns {string} レイヤー名
   */
  function getLayerName(color, index, namingMode = 'color') {
    // 命名モードに応じてレイヤー名を生成
    switch (namingMode) {
      case 'color':
        // 色名ベースのレイヤー名
        return colorToName(color);
        
      case 'index':
        // インデックスベースのレイヤー名
        return `レイヤー ${index + 1}`;
        
      case 'auto':
        // 自動判定（グレースケールの場合はインデックス、それ以外は色名）
        if (isGrayscale(color)) {
          const brightness = Math.round((color[0] + color[1] + color[2]) / 3);
          if (brightness < 30) return '黒';
          if (brightness > 225) return '白';
          return `グレー (${brightness})`;
        } else {
          return colorToName(color);
        }
        
      default:
        // デフォルトは色名
        return colorToName(color);
    }
  }
  
  /**
   * イラストレーター互換のSVGを作成します
   * @param {Array} layers - レイヤー情報の配列
   * @param {number} width - SVGの幅
   * @param {number} height - SVGの高さ
   * @param {Object} options - オプション設定
   * @returns {string} SVGデータ
   */
  function createAICompatSVG(layers, width, height, options = {}) {
    // SVGヘッダー（イラストレーター互換の名前空間を含む）
    let svg = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg xmlns="http://www.w3.org/2000/svg" 
     xmlns:xlink="http://www.w3.org/1999/xlink"
     xmlns:ai="http://ns.adobe.com/AdobeIllustrator/10.0/"
     xmlns:graph="http://ns.adobe.com/Graphs/1.0/"
     width="${width}" 
     height="${height}" 
     viewBox="0 0 ${width} ${height}"
     version="1.1">
  <metadata>
    <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
             xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
             xmlns:dc="http://purl.org/dc/elements/1.1/">
      <rdf:Description rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:title>SVG Wizard Output</dc:title>
        <dc:creator>SVG Wizard</dc:creator>
        <dc:description>Generated by SVG Wizard</dc:description>
      </rdf:Description>
    </rdf:RDF>
  </metadata>
  
  <!-- Adobe Illustrator Layer Structure -->
  <g id="Layers" ai:seqID="1" ai:layerCount="${layers.length}">`;
    
    // レイヤーを追加（逆順で追加して正しい重ね順にする）
    for (let i = layers.length - 1; i >= 0; i--) {
      const layer = layers[i];
      
      // 表示/非表示スタイル
      const visibilityStyle = layer.visible ? '' : 'display:none;';
      
      // レイヤーを追加
      svg += `
    <g id="${layer.id}" ai:layer="true" ai:layerName="${layer.name}" ai:seqID="${i+1}" style="${visibilityStyle}" fill="${layer.color}">
      ${layer.content || ''}
    </g>`;
    }
    
    // SVGフッター
    svg += `
  </g>
</svg>`;
    
    return svg;
  }
  
  /**
   * Photopea互換のSVGを作成します
   * @param {Array} layers - レイヤー情報の配列
   * @param {number} width - SVGの幅
   * @param {number} height - SVGの高さ
   * @param {Object} options - オプション設定
   * @returns {string} SVGデータ
   */
  function createPhotopeaCompatSVG(layers, width, height, options = {}) {
    // SVGヘッダー（Photopea互換の名前空間を含む）
    let svg = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg xmlns="http://www.w3.org/2000/svg" 
     xmlns:xlink="http://www.w3.org/1999/xlink"
     xmlns:photopea="http://www.photopea.com"
     width="${width}" 
     height="${height}" 
     viewBox="0 0 ${width} ${height}"
     version="1.1"
     data-photopea-document="true"
     data-photopea-version="4.0.0"
     data-created="${new Date().toISOString()}"
     data-software="SVG Wizard">
  <metadata>
    <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
             xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
             xmlns:dc="http://purl.org/dc/elements/1.1/"
             xmlns:photopea="http://www.photopea.com/rdf#">
      <rdf:Description rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:title>SVG Wizard Output</dc:title>
        <dc:creator>SVG Wizard</dc:creator>
        <dc:description>Generated by SVG Wizard</dc:description>
        <photopea:layerCount>${layers.length}</photopea:layerCount>
        <photopea:documentWidth>${width}</photopea:documentWidth>
        <photopea:documentHeight>${height}</photopea:documentHeight>
      </rdf:Description>
    </rdf:RDF>
  </metadata>
  
  <!-- Photopea Document Structure -->
  <g id="document" data-photopea-root="true" data-name="Document">`;
    
    // レイヤーを追加（逆順で追加して正しい重ね順にする）
    for (let i = layers.length - 1; i >= 0; i--) {
      const layer = layers[i];
      
      // 表示/非表示スタイル
      const visibilityStyle = layer.visible ? '' : 'display:none;';
      
      // Photopea属性を文字列に変換
      let photopeaAttrsStr = '';
      if (layer.photopeaAttributes) {
        for (const [key, value] of Object.entries(layer.photopeaAttributes)) {
          photopeaAttrsStr += ` ${key}="${value}"`;
        }
      } else {
        // 基本的なPhotopea属性
        photopeaAttrsStr = ` data-photopea-layer="true" data-name="${layer.name}" data-id="${layer.id}" data-color="${layer.color}" data-layer-type="vector"`;
      }
      
      // レイヤーを追加
      svg += `
    <g id="${layer.id}" style="${visibilityStyle}" fill="${layer.color}"${photopeaAttrsStr}>
      ${layer.content || ''}
    </g>`;
    }
    
    // SVGフッター
    svg += `
  </g>
</svg>`;
    
    return svg;
  }
  
  /**
   * 標準的なレイヤー構造のSVGを作成します
   * @param {Array} layers - レイヤー情報の配列
   * @param {number} width - SVGの幅
   * @param {number} height - SVGの高さ
   * @returns {string} SVGデータ
   */
  function createLayeredSVG(layers, width, height) {
    // SVGヘッダー
    let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">`;
    
    // レイヤーを追加
    for (let i = 0; i < layers.length; i++) {
      const layer = layers[i];
      
      // 表示/非表示スタイル
      const visibilityStyle = layer.visible ? '' : 'display:none;';
      
      // レイヤーを追加
      svg += `
  <g id="${layer.id}" data-name="${layer.name}" style="${visibilityStyle}" fill="${layer.color}">
    ${layer.content || ''}
  </g>`;
    }
    
    // SVGフッター
    svg += `
</svg>`;
    
    return svg;
  }
  
  /**
   * 汎用的なグラフィックソフト互換のSVGを作成します
   * @param {Array} layers - レイヤー情報の配列
   * @param {number} width - SVGの幅
   * @param {number} height - SVGの高さ
   * @param {Object} options - オプション設定
   * @returns {string} SVGデータ
   */
  function createUniversalCompatSVG(layers, width, height, options = {}) {
    // SVGヘッダー（複数のグラフィックソフト互換の名前空間を含む）
    let svg = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg xmlns="http://www.w3.org/2000/svg" 
     xmlns:xlink="http://www.w3.org/1999/xlink"
     xmlns:ai="http://ns.adobe.com/AdobeIllustrator/10.0/"
     xmlns:graph="http://ns.adobe.com/Graphs/1.0/"
     xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
     xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
     xmlns:photopea="http://www.photopea.com"
     width="${width}" 
     height="${height}" 
     viewBox="0 0 ${width} ${height}"
     version="1.1"
     data-photopea-document="true"
     inkscape:version="1.0"
     sodipodi:docname="universal_compat.svg">
  <metadata>
    <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
             xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
             xmlns:dc="http://purl.org/dc/elements/1.1/">
      <rdf:Description rdf:about="">
        <dc:format>image/svg+xml</dc:format>
        <dc:title>SVG Wizard Output</dc:title>
        <dc:creator>SVG Wizard</dc:creator>
        <dc:description>Generated by SVG Wizard</dc:description>
      </rdf:Description>
    </rdf:RDF>
  </metadata>
  
  <!-- Universal Layer Structure -->
  <g id="Layers" ai:layerCount="${layers.length}" inkscape:groupmode="layer" inkscape:label="Layers" data-photopea-root="true">`;
    
    // レイヤーを追加（逆順で追加して正しい重ね順にする）
    for (let i = layers.length - 1; i >= 0; i--) {
      const layer = layers[i];
      
      // 表示/非表示スタイル
      const visibilityStyle = layer.visible ? '' : 'display:none;';
      
      // レイヤーを追加（複数のグラフィックソフト互換の属性を含む）
      svg += `
    <g id="${layer.id}" 
       style="${visibilityStyle}" 
       fill="${layer.color}"
       ai:layer="true" 
       ai:layerName="${layer.name}" 
       ai:seqID="${i+1}"
       inkscape:groupmode="layer" 
       inkscape:label="${layer.name}"
       sodipodi:insensitive="${!layer.visible}"
       data-photopea-layer="true"
       data-name="${layer.name}"
       data-id="${layer.id}"
       data-color="${layer.color}"
       data-layer-type="vector">
      ${layer.content || ''}
    </g>`;
    }
    
    // SVGフッター
    svg += `
  </g>
</svg>`;
    
    return svg;
  }
  
  /**
   * レイヤーの表示/非表示を設定します
   * @param {string} svgData - SVGデータ文字列
   * @param {string} layerId - レイヤーID
   * @param {boolean} visible - 表示状態
   * @returns {string} 更新されたSVGデータ
   */
  function setLayerVisibility(svgData, layerId, visible) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(svgData, 'image/svg+xml');
    
    const layer = doc.getElementById(layerId);
    if (layer) {
      const style = layer.getAttribute('style') || '';
      const newStyle = visible
        ? style.replace(/display:\s*none/g, 'display:inline')
        : style.replace(/display:\s*inline/g, 'display:none');
      
      layer.setAttribute('style', newStyle || (visible ? 'display:inline' : 'display:none'));
    }
    
    return new XMLSerializer().serializeToString(doc);
  }
  
  /**
   * レイヤーの色を更新します
   * @param {string} svgData - SVGデータ文字列
   * @param {string} layerId - レイヤーID
   * @param {string} color - 新しい色（16進数）
   * @returns {string} 更新されたSVGデータ
   */
  function updateLayerColor(svgData, layerId, color) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(svgData, 'image/svg+xml');
    
    const layer = doc.getElementById(layerId);
    if (layer) {
      // レイヤー内のすべてのパス要素の色を変更
      const paths = layer.querySelectorAll('path');
      paths.forEach(path => {
        path.setAttribute('fill', color);
        
        // data-color属性も更新
        layer.setAttribute('data-color', color);
      });
    }
    
    return new XMLSerializer().serializeToString(doc);
  }
  
  /**
   * SVGデータからレイヤー情報を抽出します
   * @param {string} svgData - SVGデータ文字列
   * @returns {Array} レイヤー情報の配列
   */
  function extractLayers(svgData) {
    if (!svgData) {
      console.error('SVGデータが指定されていません');
      return [];
    }
    
    try {
      // DOMパーサーを使用してSVGを解析
      const parser = new DOMParser();
      const doc = parser.parseFromString(svgData, 'image/svg+xml');
      
      const layers = [];
      
      // SVGグループ要素をレイヤーとして処理
      const groups = doc.querySelectorAll('g');
      
      for (let i = 0; i < groups.length; i++) {
        const group = groups[i];
        
        // ルートグループはスキップ
        if (group.getAttribute('data-photopea-root') === 'true' || 
            group.getAttribute('ai:layerCount') || 
            group.getAttribute('id') === 'Layers') {
          continue;
        }
        
        // レイヤーID
        const id = group.getAttribute('id') || `layer_${i}`;
        
        // レイヤー名を取得（様々な属性をチェック）
        let name = group.getAttribute('data-name') || 
                  group.getAttribute('ai:layerName') || 
                  group.getAttribute('inkscape:label') || 
                  `レイヤー ${i + 1}`;
        
        // レイヤーの色
        let color = group.getAttribute('data-color') || group.getAttribute('fill');
        
        // 色が指定されていない場合はパスから取得
        if (!color) {
          const paths = group.querySelectorAll('path');
          if (paths.length > 0) {
            color = paths[0].getAttribute('fill');
          }
        }
        
        if (!color) {
          color = '#000000';
        }
        
        // 表示/非表示状態
        const style = group.getAttribute('style') || '';
        const visible = !style.includes('display:none');
        
        // Photopea特有の属性を収集
        const photopeaAttributes = {};
        const dataAttributes = Array.from(group.attributes)
          .filter(attr => attr.name.startsWith('data-'));
        
        dataAttributes.forEach(attr => {
          photopeaAttributes[attr.name] = attr.value;
        });
        
        // レイヤー情報を追加
        layers.push({
          id: id,
          name: name,
          color: color,
          visible: visible,
          photopeaAttributes: photopeaAttributes
        });
      }
      
      return layers;
    } catch (error) {
      console.error('レイヤー抽出エラー:', error);
      return [];
    }
  }
  
  /**
   * RGB値を16進数カラーコードに変換します
   * @param {number} r - 赤（0-255）
   * @param {number} g - 緑（0-255）
   * @param {number} b - 青（0-255）
   * @returns {string} 16進数カラーコード
   */
  function rgbToHex(r, g, b) {
    return '#' + [r, g, b].map(x => {
      const hex = Math.round(x).toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    }).join('');
  }
  
  /**
   * 色がグレースケールかどうかを判定します
   * @param {Array} color - 色情報 [R, G, B]
   * @param {number} tolerance - 許容差
   * @returns {boolean} グレースケールならtrue
   */
  function isGrayscale(color, tolerance = 10) {
    const [r, g, b] = color;
    return Math.abs(r - g) <= tolerance && 
           Math.abs(g - b) <= tolerance && 
           Math.abs(r - b) <= tolerance;
  }
  
  /**
   * RGB値から色名を推定します
   * @param {Array} color - 色情報 [R, G, B]
   * @returns {string|null} 色名または null
   */
  function colorToName(color) {
    const [r, g, b] = color;
    
    // グレースケールの場合
    if (isGrayscale(color)) {
      const brightness = Math.round((r + g + b) / 3);
      if (brightness < 32) return '黒';
      if (brightness < 64) return '暗いグレー';
      if (brightness < 128) return 'グレー';
      if (brightness < 196) return '明るいグレー';
      if (brightness < 240) return '薄いグレー';
      return '白';
    }
    
    // 一般的な色の判定（単純な方法）
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const diff = max - min;
    const hue = getHue(r, g, b);
    const sat = max === 0 ? 0 : diff / max;
    const val = max / 255;
    
    // 彩度が低い場合
    if (sat < 0.2) {
      return null; // 特定の色名に分類しない
    }
    
    // 明度が非常に低い場合
    if (val < 0.2) {
      return '暗い色';
    }
    
    // 色相に基づく色名
    if (hue >= 345 || hue < 15) return '赤';
    if (hue >= 15 && hue < 45) return 'オレンジ';
    if (hue >= 45 && hue < 75) return '黄色';
    if (hue >= 75 && hue < 105) return '黄緑';
    if (hue >= 105 && hue < 135) return '緑';
    if (hue >= 135 && hue < 165) return '青緑';
    if (hue >= 165 && hue < 195) return 'シアン';
    if (hue >= 195 && hue < 225) return '水色';
    if (hue >= 225 && hue < 255) return '青';
    if (hue >= 255 && hue < 285) return '青紫';
    if (hue >= 285 && hue < 315) return '紫';
    if (hue >= 315 && hue < 345) return 'マゼンタ';
    
    return null;
  }
  
  /**
   * RGB値から色相を計算します
   * @param {number} r - 赤（0-255）
   * @param {number} g - 緑（0-255）
   * @param {number} b - 青（0-255）
   * @returns {number} 色相（0-359）
   */
  function getHue(r, g, b) {
    r /= 255;
    g /= 255;
    b /= 255;
    
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    
    let h;
    
    if (max === min) {
      h = 0; // グレースケール
    } else if (max === r) {
      h = 60 * (0 + (g - b) / (max - min));
    } else if (max === g) {
      h = 60 * (2 + (b - r) / (max - min));
    } else {
      h = 60 * (4 + (r - g) / (max - min));
    }
    
    if (h < 0) h += 360;
    
    return h;
  }
  
  // 公開API
  return {
    createLayers: createLayers,
    getLayerName: getLayerName,
    createAICompatSVG: createAICompatSVG,
    createPhotopeaCompatSVG: createPhotopeaCompatSVG,
    createLayeredSVG: createLayeredSVG,
    createUniversalCompatSVG: createUniversalCompatSVG,
    setLayerVisibility: setLayerVisibility,
    updateLayerColor: updateLayerColor,
    extractLayers: extractLayers,
    
    // ユーティリティ関数
    rgbToHex: rgbToHex,
    isGrayscale: isGrayscale,
    colorToName: colorToName,
    getHue: getHue
  };
})(); 